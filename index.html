<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
<title>LIMENWALKER WORKSHOP</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#000000">

<style>
  :root{
    --vwpx:100vw; --vhpx:100vh;
    --gap:32px; --line-color:rgba(255,255,255,.9);
    --line-w:1px; --line-r:2px;
    --ff:"Courier New", Courier, monospace;
  }
  html,body{
    margin:0;height:100%;background:#000;color:#fff;
    font-family:var(--ff); overflow:hidden;
    -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent;
  }
  *,*::before,*::after{ box-sizing:border-box; font-family:var(--ff); }
  button,input,select,textarea{ font:inherit; color:inherit; }

  /* 레이어: 카메라(0) ← 궤적(2) ← 레졸룸(4) ← UI(10) */
  #cameraView{
    position:fixed; inset:0; width:var(--vwpx); height:var(--vhpx);
    object-fit:cover; background:#000; z-index:0;
    filter:grayscale(1) contrast(1.2);
    will-change:transform, opacity; transform:translateZ(0); backface-visibility:hidden;
  }
  #trailCanvas{
    position:fixed; inset:0; width:var(--vwpx); height:var(--vhpx);
    z-index:2; pointer-events:none; background:transparent; will-change:opacity;
  }
  #ninjaOverlay{
    position:fixed; left:50%; top:50%;
    width:var(--vwpx); height:var(--vhpx);
    transform:translate(-50%,-50%) scale(1); transform-origin:50% 50%;
    border:0; background:transparent; image-rendering:auto;
    z-index:4; pointer-events:none; opacity:0; transition:opacity .25s ease;
    mix-blend-mode: screen; /* 악몽 코드 감각 */
    will-change:opacity, transform;
  }

  .proscenium{
    position:fixed;
    left:calc(var(--gap) + env(safe-area-inset-left));
    right:calc(var(--gap) + env(safe-area-inset-right));
    top:calc(var(--gap) + env(safe-area-inset-top));
    bottom:calc(var(--gap) + env(safe-area-inset-bottom));
    border:var(--line-w) solid var(--line-color);
    border-radius:var(--line-r);
    pointer-events:none; z-index:5;
  }

  /* 중앙 안내(작게 + 중앙 고정, 터치는 통과) */
  #infoText, #overlay{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; text-align:center;
  }
  #infoText{
    font-size:clamp(12px,1.8vmin,16px); opacity:.9; z-index:8; pointer-events:none;
  }
  #overlay{
    background:rgba(0,0,0,.65);
    z-index:10; line-height:1.55; transition:opacity .25s ease;
  }
  #overlay.hidden{ opacity:0; pointer-events:none; }
  .centerText{ text-align:center; white-space:pre-line; font-size:clamp(13px,1.9vmin,17px); }
  .stageText{ text-align:left; white-space:pre-line; max-width:90vw; font-size:clamp(12px,1.7vmin,16px); }
  .stageBtn{
    border:1px solid #fff; background:transparent; color:#fff;
    padding:.5em 1.1em; text-transform:uppercase; margin-top:14px;
    font-size:clamp(12px,1.7vmin,16px); cursor:pointer;
  }
  #countdown{ font-size:clamp(11px,1.6vmin,15px); opacity:.8; margin-top:12px; display:none; }

  /* ▼ 180초 타이머 */
  #cornerTimer{
    position:fixed;
    right:calc(12px + env(safe-area-inset-right));
    bottom:calc(10px + env(safe-area-inset-bottom));
    z-index:20;
    font-size:clamp(12px,1.8vmin,16px);
    opacity:.95;
    background:rgba(0,0,0,.35);
    padding:6px 10px;
    border:1px solid rgba(255,255,255,.6);
    border-radius:6px;
    pointer-events:none;
    display:none;
  }

  /* ▼ THE END (검정 박스 없이, 화면 가득 크게) */
  #theEnd{
    position:fixed; inset:0; z-index:30;
    display:none; align-items:center; justify-content:center;
    color:#fff; background:transparent; text-align:center;
    font-weight:700; letter-spacing:.12em;
    font-size:min(18vmin, 12rem);
    text-shadow:0 0 18px rgba(255,255,255,.22);
    pointer-events:none;
    transition:opacity .6s ease;
    opacity:0;
  }
  #theEnd.show{ display:flex; opacity:1; }
</style>
</head>
<body>

<video id="cameraView" autoplay muted playsinline></video>
<canvas id="trailCanvas"></canvas>

<iframe id="ninjaOverlay"
  allow="autoplay; camera; microphone; fullscreen; clipboard-read; clipboard-write"
  allowtransparency="true" referrerpolicy="no-referrer" src="about:blank">
</iframe>

<div class="proscenium" aria-hidden="true"></div>

<div id="infoText">
  화면을 터치하면 카메라/마이크/센서 권한을 요청합니다.
</div>

<div id="overlay" class="hidden">
  <div id="msg" class="centerText"></div>
  <button id="startBtn" class="stageBtn" style="display:none;">PRESS HERE TO START</button>
  <div id="countdown"></div>
</div>

<!-- ▼ 180초 타이머 -->
<div id="cornerTimer">03:00</div>

<!-- ▼ THE END 스크린 -->
<div id="theEnd">THE END</div>

<script>
(()=> {
/* ===== Config (악몽 코드 감각 반영) ===== */
const CONFIG = {
  ROOM_ID: "YOURROOMID",
  REZ_SCALE: 0.65,
  LINE_WIDTH: 0.6,
  LINE_DASH: [1.5,10],
  LAYERS: {
    WELCOME: { CAMERA: 1.00, NINJA: 0.50, TRAIL: 0.00 },
    GUIDE:   { CAMERA: 1.00, NINJA: 0.50, TRAIL: 0.00 },
    WALK:    { CAMERA: 0.95, NINJA: 0.45, TRAIL: 0.95 },
    STOP:    { CAMERA: 0.95, NINJA: 0.40, TRAIL: 0.85 },
  },
  /* ▼ 궤적 민감도 업 */
  SENS: {
    M_PER_PX: 0.35,           // 더 민감하게: 0.35m 당 1px
    MIN_STEP_M: 0.03,         // 최소 거리(미만이면 보정)
    FORCE_ADD_MS: 1200,       // 이 시간 이상 새 점 없으면 강제 추가
    MICRO_FROM_SPEED: true,   // speed/heading으로 미세 이동 합성
    MICRO_MAX_STEP_M: 0.25
  }
};

/* ===== Elements ===== */
const camView   = document.getElementById('cameraView');
const trail     = document.getElementById('trailCanvas');
const tctx      = trail.getContext('2d');
const ninja     = document.getElementById('ninjaOverlay');
const overlay   = document.getElementById('overlay');
const msg       = document.getElementById('msg');
const startBtn  = document.getElementById('startBtn');
const infoText  = document.getElementById('infoText');
const countdown = document.getElementById('countdown');
const cornerTimer = document.getElementById('cornerTimer');
const theEndEl = document.getElementById('theEnd');

/* ===== Viewport fix ===== */
function setViewportVars(){
  const vv = window.visualViewport;
  const w = Math.round((vv?.width || innerWidth));
  const h = Math.round((vv?.height || innerHeight));
  document.documentElement.style.setProperty('--vwpx', w + 'px');
  document.documentElement.style.setProperty('--vhpx', h + 'px');

  const dpr = Math.max(1, devicePixelRatio || 1);
  trail.width  = Math.floor(w * dpr);
  trail.height = Math.floor(h * dpr);
  trail.style.width  = w + 'px';
  trail.style.height = h + 'px';
  tctx.setTransform(dpr,0,0,dpr,0,0);
}
setViewportVars();
addEventListener('resize', setViewportVars);
if (visualViewport){
  visualViewport.addEventListener('resize', setViewportVars);
  visualViewport.addEventListener('scroll', setViewportVars);
}
addEventListener('orientationchange', ()=> setTimeout(setViewportVars,120));
addEventListener('pageshow', ()=>{ setTimeout(()=>{ setViewportVars(); applyRezScale(); }, 60); });

/* ===== Audio ===== */
let audioCtx;
function initAudioContext(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
}
function beep(freq=880, dur=120){
  try{
    initAudioContext();
    const osc = audioCtx.createOscillator(), g = audioCtx.createGain();
    osc.type='square'; osc.frequency.value=freq; g.gain.value=0.0001;
    osc.connect(g).connect(audioCtx.destination);
    const t = audioCtx.currentTime;
    g.gain.exponentialRampToValueAtTime(0.25,t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur/1000);
    osc.start(t); osc.stop(t+dur/1000+0.02);
  }catch{}
}
/* 80Hz 10초 재생 */
function playTone(freq=80, duration=10000){
  try{
    initAudioContext();
    const osc=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    osc.type='sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.value=0.0001;
    osc.connect(g).connect(audioCtx.destination);
    const t=audioCtx.currentTime;
    g.gain.exponentialRampToValueAtTime(0.3, t+0.15);
    g.gain.setTargetAtTime(0.28, t+0.5, 0.5);
    g.gain.setTargetAtTime(0.0001, t + duration/1000 - 0.2, 0.15);
    osc.start(t);
    osc.stop(t + duration/1000 + 0.02);
  }catch(e){ console.warn('tone play failed', e); }
}

/* ===== Wake Lock ===== */
let wakeLock = null;
async function keepScreenOn(){
  try{
    if('wakeLock' in navigator){
      wakeLock = await navigator.wakeLock.request('screen');
      document.addEventListener('visibilitychange', async ()=>{
        if(document.visibilityState==='visible' && !wakeLock){
          try{ wakeLock = await navigator.wakeLock.request('screen'); }catch{}
        }
      });
    }
  }catch{}
}

/* ===== Overlay helpers ===== */
function showOverlayText(text, center=true){
  msg.className = center ? 'centerText' : 'stageText';
  msg.textContent = text;
  overlay.classList.remove('hidden');
}
function hideOverlay(){ overlay.classList.add('hidden'); }

/* ===== VDO.Ninja (선로딩 + 스케일) ===== */
const injectedCss = encodeURIComponent(`
  html,body{background:transparent!important;margin:0!important;overflow:hidden!important;}
  #container,.container{background:transparent!important;}
  video,canvas{position:fixed!important; inset:0!important; width:100vw!important; height:100vh!important; object-fit:cover!important; background:transparent!important;}
`);
const ninjaBase = `https://vdo.ninja/?view=${encodeURIComponent(CONFIG.ROOM_ID)}&clean&autostart&noaudio&codec=vp8&solo&transparent=1&css=${injectedCss}`;
const ninjaUrl  = () => `${ninjaBase}&ts=${Date.now()}`;

function applyRezScale(){
  const s = Math.max(0.2, Math.min(1, Number(CONFIG.REZ_SCALE)||1));
  ninja.style.width  = `calc(var(--vwpx) * ${s})`;
  ninja.style.height = `calc(var(--vhpx) * ${s})`;
  ninja.style.left = '50%'; ninja.style.top = '50%';
  ninja.style.transform = `translate(-50%,-50%) scale(${1/s})`;
}
applyRezScale();

/* 선로딩 */
(function preloadOverlay(){
  if(!ninja.src || ninja.src === 'about:blank'){ ninja.src = ninjaUrl(); }
})();
setInterval(()=>{ if(parseFloat(getComputedStyle(ninja).opacity)||0){ ninja.src = ninjaUrl(); } }, 60000);

/* ===== Layer ratio control ===== */
let state = 'WELCOME';
function applyLayerMix(){
  const M = CONFIG.LAYERS[state] || CONFIG.LAYERS.WELCOME;
  camView.style.opacity = String(M.CAMERA);
  ninja.style.opacity   = String(M.NINJA);
  trail.style.opacity   = String(M.TRAIL);
}

/* ===== Sensors & Trajectory (공용 값/함수) ===== */
let points = [];
let drawingEnabled = false;
/* 더 예민하게: 1px당 0.35m */
let metersPerPixel = CONFIG.SENS.M_PER_PX;
const MAX_POINTS = 3000;
const DECAY_START = 10_000, MAX_AGE = 60_000, MAX_JITTER = 18;
let motionMag = 0;

function onMotion(e){
  const ax=e.accelerationIncludingGravity?.x||0, ay=e.accelerationIncludingGravity?.y||0, az=e.accelerationIncludingGravity?.z||0;
  motionMag = motionMag * 0.9 + Math.hypot(ax,ay,az) * 0.1;
}
function enableMotionIfNeeded(){
  try{
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      DeviceMotionEvent.requestPermission().catch(()=>{});
    }
  }catch{}
  addEventListener('devicemotion', onMotion, {passive:true});
}

/* 방향 추정을 위한 폴백 (heading 미제공 시) */
let lastYaw = 0;
addEventListener('deviceorientation', (e)=>{ 
  // iOS의 alpha는 보정 안될 수 있지만 미세 이동 방향용으로만 사용
  const a = (e.alpha ?? lastYaw) * Math.PI/180;
  if(Number.isFinite(a)) lastYaw = a;
}, {passive:true});

const M_PER_DEG = 111320;
function llToMeters(lat0, lon0, lat, lon){
  const x = (lon - lon0) * Math.cos(lat0 * Math.PI/180) * M_PER_DEG;
  const y = (lat - lat0) * M_PER_DEG;
  return {x, y};
}
function metersToCanvas(xm, ym){
  const w = trail.clientWidth, h = trail.clientHeight;
  const cx = w/2, cy = h/2;
  return { x: cx + xm / metersPerPixel, y: cy - ym / metersPerPixel };
}
function jitterFor(age){
  const frac = Math.min(1, Math.max(0, (age-DECAY_START)/(MAX_AGE-DECAY_START)));
  const motionBoost = Math.min(1, Math.max(0, (motionMag-5)/10));
  return (MAX_JITTER * frac) * (0.5 + 0.5*motionBoost);
}
function drawTrajectory(){
  const now = performance.now();
  tctx.fillStyle = 'rgba(0,0,0,0.06)';
  tctx.fillRect(0,0,trail.clientWidth, trail.clientHeight);
  if(points.length < 2 || !drawingEnabled) return;
  tctx.save();
  tctx.lineWidth = CONFIG.LINE_WIDTH;
  tctx.setLineDash(CONFIG.LINE_DASH);
  for(let i=1;i<points.length;i++){
    const a = points[i-1], b = points[i];
    const age = now - b.t; if(age > MAX_AGE) continue;
    const alpha = age <= DECAY_START ? 0.9 : Math.max(0, 0.9 * (1 - (age-DECAY_START)/(MAX_AGE-DECAY_START)));
    const j = age > DECAY_START ? jitterFor(age) : 0;
    const jx1=(Math.random()-0.5)*2*j, jy1=(Math.random()-0.5)*2*j;
    const jx2=(Math.random()-0.5)*2*j, jy2=(Math.random()-0.5)*2*j;
    tctx.strokeStyle = `rgba(255,255,255,${alpha})`;
    tctx.beginPath();
    tctx.moveTo(a.x + jx1, a.y + jy1);
    tctx.lineTo(b.x + jx2, b.y + jy2);
    tctx.stroke();
  }
  tctx.restore();
  const cutoff = now - MAX_AGE;
  if(points.length && points[0].t < cutoff){
    let idx=0; while(idx < points.length && points[idx].t < cutoff) idx++;
    if(idx>0) points.splice(0, idx);
  }
}
let rafId=null; function loop(){ drawTrajectory(); rafId = requestAnimationFrame(loop); }

/* ===== GPS: 초민감 + 하트비트 + 미세 이동 합성 ===== */
let gpsWatchId = null, firstFix = null;
let lastFixTime = 0;
let gpsHeartbeat = null;
const GPS_OPTS = { enableHighAccuracy:true, maximumAge:0, timeout:5000 };

let lastXm=null, lastYm=null, lastAddTime=0, lastHeadingRad=0;
function hypot2(ax, ay, bx, by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); }

function addPointMeters(xm, ym){
  const p = metersToCanvas(xm, ym);
  points.push({ x:p.x, y:p.y, t:performance.now(), speed:0 });
  if(points.length > MAX_POINTS) points.shift();
  lastXm=xm; lastYm=ym; lastAddTime=Date.now();
}

function handlePosition(pos){
  const { latitude:lat, longitude:lon, speed=0, heading=null } = pos.coords;
  if(!firstFix){ firstFix = { lat, lon }; lastFixTime = Date.now(); const m0=llToMeters(firstFix.lat, firstFix.lon, lat, lon); addPointMeters(m0.x, m0.y); return; }
  const m  = llToMeters(firstFix.lat, firstFix.lon, lat, lon);
  const now = Date.now();
  let moved = true;

  if(lastXm!=null && lastYm!=null){
    const dist = hypot2(m.x, m.y, lastXm, lastYm); // m 단위
    if(dist >= CONFIG.SENS.MIN_STEP_M){
      addPointMeters(m.x, m.y);
      lastHeadingRad = Number.isFinite(heading) ? (heading*Math.PI/180) : lastHeadingRad;
    }else{
      moved = false;
      // 미세 이동 합성 (speed/heading 또는 yaw, motion)
      if(CONFIG.SENS.MICRO_FROM_SPEED){
        let dir = Number.isFinite(heading) ? (heading*Math.PI/180) : (lastHeadingRad || lastYaw);
        const base = Math.min(CONFIG.SENS.MICRO_MAX_STEP_M,
                              Math.max(0.035, speed*0.45 + Math.min(0.12, (motionMag-9)*0.012)));
        if(base > 0.03){
          const nx = lastXm + Math.cos(dir)*base;
          const ny = lastYm + Math.sin(dir)*base;
          addPointMeters(nx, ny);
        }
      }
      // 강제 주기적 추가 (정지처럼 보여도 최소 드리프트)
      if(now - lastAddTime > CONFIG.SENS.FORCE_ADD_MS){
        const eps = 0.05; // 5cm 미묘한 드리프트
        const nx = (lastXm??m.x) + (Math.random()-0.5)*2*eps;
        const ny = (lastYm??m.y) + (Math.random()-0.5)*2*eps;
        addPointMeters(nx, ny);
      }
    }
  }else{
    addPointMeters(m.x, m.y);
  }

  lastFixTime = now;
}

function startGPS(){
  stopGPS();
  firstFix = null;
  lastXm=lastYm=null; lastAddTime=0;

  navigator.geolocation.getCurrentPosition(
    (pos)=>{ handlePosition(pos); },
    (err)=>{ console.warn('getCurrentPosition error:', err); },
    GPS_OPTS
  );
  try{
    gpsWatchId = navigator.geolocation.watchPosition(
      handlePosition,
      (err)=>{ console.warn('watchPosition error:', err); },
      GPS_OPTS
    );
  }catch(e){ console.warn('watchPosition failed:', e); }

  // 하트비트: 1초마다 깨우기 (아주 예민)
  if(!gpsHeartbeat){
    gpsHeartbeat = setInterval(()=>{
      const stale = Date.now() - lastFixTime;
      if(stale > 1500){
        navigator.geolocation.getCurrentPosition(
          (pos)=>{ handlePosition(pos); },
          ()=>{}, GPS_OPTS
        );
      }
    }, 1000);
  }
}

function stopGPS(){
  try{ if(gpsWatchId!=null){ navigator.geolocation.clearWatch(gpsWatchId); } }catch{}
  gpsWatchId = null;
}

/* ===== Media (카메라/마이크) + 워치독 ===== */
let currentStream = null, ensureTimer = null, restartTimer = null;
async function startCamera(){
  const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:"environment" } }, audio:false });
  currentStream = stream;
  camView.srcObject = stream;
  camView.muted = true;
  camView.setAttribute('playsinline','');
  camView.load();
  try { await camView.play(); } catch {}
  bindTrackGuards(stream);
  pingEnsurePlaying();
}
async function startMic(){ try{ await navigator.mediaDevices.getUserMedia({ audio:true }); }catch{} }
function bindTrackGuards(stream){
  stream.getVideoTracks().forEach(tr=>{
    tr.onended  = ()=>{ restartCameraSoon(); };
    tr.onmute   = ()=>{ pingEnsurePlaying(); };
    tr.onunmute = ()=>{ pingEnsurePlaying(); };
  });
}
function restartCameraSoon(ms=350){
  if(restartTimer) return;
  restartTimer = setTimeout(async ()=>{
    restartTimer=null;
    try{ if(currentStream) currentStream.getTracks().forEach(t=>t.stop()); }catch{}
    currentStream=null;
    try{ await startCamera(); }catch(e){ console.error('restart camera fail',e); }
  }, ms);
}
function pingEnsurePlaying(){
  if(ensureTimer) return;
  ensureTimer = setInterval(()=>{
    if(camView.readyState >= 2 && camView.paused){ camView.play().catch(()=>{}); }
    const ok = currentStream && currentStream.getVideoTracks().some(t=>t.readyState==='live');
    if(!ok) restartCameraSoon(100);
  }, 1000);
}

/* ===== Input binder ===== */
function onPress(el, handler){
  let fired=false;
  const wrap=(e)=>{ if(fired) return; fired=true; e.preventDefault(); e.stopPropagation(); handler(); };
  el.addEventListener('touchend', wrap, { once:true, passive:false });
  el.addEventListener('click', wrap, { once:true });
}

/* ===== 180초 타이머 + 엔딩 ===== */
let exploreTimerId=null, exploreRemain=0;
function fmt(t){ const m=String(Math.floor(t/60)).padStart(2,'0'); const s=String(t%60).padStart(2,'0'); return `${m}:${s}`; }
function startExploreTimer(seconds=180){
  exploreRemain=seconds;
  cornerTimer.textContent=fmt(exploreRemain);
  cornerTimer.style.display='block';
  if(exploreTimerId) clearInterval(exploreTimerId);
  exploreTimerId=setInterval(()=>{
    exploreRemain--;
    if(exploreRemain<=0){
      cornerTimer.textContent='00:00';
      clearInterval(exploreTimerId); exploreTimerId=null;
      // 80Hz 10초 재생 후 THE END 표시
      playTone(80, 10000);
      setTimeout(()=>{
        cornerTimer.style.display='none';
        theEndEl.classList.add('show');
      }, 10000);
      return;
    }
    cornerTimer.textContent=fmt(exploreRemain);
  },1000);
}

/* ===== Flow ===== */
onPress(window, async ()=>{
  initAudioContext(); keepScreenOn();
  infoText.style.display='none';

  await startCamera().catch(e=>console.error('camera start fail',e));
  await startMic().catch(e=>console.warn('mic denied', e));

  enableMotionIfNeeded(); startGPS(); if(!rafId) loop();

  applyRezScale();
  if(!ninja.contentWindow) ninja.src = ninjaUrl();

  state='WELCOME'; applyLayerMix();
  stepWelcome();
});

function stepWelcome(){
  showOverlayText('WELCOME TO LIMENWALKER WORKSHOP', true);
  setTimeout(()=>{
    beep(880,120);
    msg.textContent='';
    countdown.style.display='none';
    startBtn.style.display='inline-block';
    state='WELCOME'; applyLayerMix();
  },3000);
}

let guideTimer=null;
onPress(startBtn, async ()=>{
  if(guideTimer) return;
  beep(660,150);
  startBtn.style.display='none';
  showOverlayText(formatGuide(), false);

  state='GUIDE'; applyLayerMix();

  let sec=60;
  countdown.style.display='block';
  countdown.textContent=`${sec}초 후 탐사가 시작됩니다.`;
  guideTimer=setInterval(()=>{
    sec--;
    countdown.textContent=`${sec}초 후 탐사가 시작됩니다.`;
    if(sec<=0){
      clearInterval(guideTimer); guideTimer=null;
      countdown.style.display='none';
      stepWalkStop();
    }
  },1000);
});

/* ▼ WALK/STOP 문구 교체 + 3단계 안내 */
function stepWalkStop(){
  drawingEnabled = true;

  state='WALK'; applyLayerMix();
  showOverlayText('당신은 문지방을 밟으며 걷을 수 있다.', true);

  setTimeout(()=>{
    state='STOP'; applyLayerMix();
    showOverlayText('당신은 문지방의 끝에서 멈춰 설 수 있다.', true);

    setTimeout(()=>{
      showOverlayText('자유롭게 거닐어라', true);
      setTimeout(()=>{ hideOverlay(); startExploreTimer(180); }, 3000);
    }, 3000);
  }, 3000);
}

/* 안내문(원문 유지, 폰트만 작게) */
function formatGuide(){
  const lines = [
    "안녕하세요. 리멘워커 워크숍의 첫 번째 워크숍 발표를 찾아와주신 여러분에게 감사의 인사를 올립니다.",
    "이곳은 무작위로 수집된 시간이 이성적으로 분류되어 예측가능한 현실로 구성된 공간입니다.",
    "어느 날, 이곳에 존재하던 ‘무작위로 수집된 시간’은 예측가능한 현실로부터 탈출하게 됩니다.",
    "잠시후, 당신의 핸드폰 스크린 위로는 ‘당신이 바라보는 현실 공간’과 ‘이 공간을 탈출한 ‘시간’이 바라보는 공간’이 동시에 투사될 것입니다.",
    "3분 간의 시간 동안 당신은 공간을 자유롭게 거닐며, 이 공간을 탈출한 ‘시간’이 바라보는 공간’이 함께 포착해 나가시면 됩니다."
  ];
  return lines.map((l,i)=>`${i+1}. ${l}`).join("\n\n");
}

/* 복귀/회전 시 UI & 레이어 재적용 + GPS 워치 재시작 */
document.addEventListener('visibilitychange', ()=>{
  if(document.visibilityState==='visible'){
    setViewportVars(); applyRezScale();
    camView.play().catch(()=>{});
    if(!currentStream){ restartCameraSoon(50); }
    applyLayerMix();
    if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
    if(!ninja.contentWindow || ninja.src==='about:blank'){ ninja.src = ninjaUrl(); }
    if(cornerTimer.style.display==='block'){
      cornerTimer.textContent = fmt(Math.max(0, exploreRemain|0));
    }
    stopGPS(); startGPS(); // GPS 재시작 (iOS 침묵 대응)
  }
});
window.addEventListener('orientationchange', ()=>{
  setTimeout(()=>{
    setViewportVars(); applyRezScale();
    camView.play().catch(()=>{});
    if(!currentStream){ restartCameraSoon(50); }
    applyLayerMix();
  },120);
});

})();
</script>
</body>
</html>
