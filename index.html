<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
<title>History of Nightmare — PWA + Rez 65% + Proscenium</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  :root{
    --vwpx: 100vw;
    --vhpx: 100vh;

    --gap: 32px;
    --line-color: rgba(255,255,255,.9);
    --line-w: 1px; --line-r: 2px;

    --ff-ui: "Courier New", Courier, monospace;
    --stage-fs: clamp(14px, 2.0vmax, 22px);
    --btn-pad-y: .45em;
    --btn-pad-x: 1.0em;
    --btn-border: 1px;
    --letter-space: .03em;
    --line-height: 1.4;
  }
  @media (orientation:landscape){
    :root{ --gap: 24px; --stage-fs: clamp(13px, 1.8vmax, 20px); }
  }

  html,body{
    margin:0;height:100%;background:#000;overflow:hidden;
    -webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;
    font-family:var(--ff-ui); font-size:16px; line-height:var(--line-height);
    text-rendering:optimizeLegibility; -webkit-font-smoothing:antialiased;
  }
  *,*::before,*::after{ box-sizing:border-box; }
  button,input,select,textarea{ font:inherit; color:inherit; }
  button{ -webkit-appearance:none; appearance:none; background:none; border:none; padding:0; margin:0; }

  /* 카메라 캔버스 */
  #view{
    position:fixed;left:0;top:0;width:var(--vwpx);height:var(--vhpx);
    display:block;z-index:0
  }

  /* VDO.Ninja 오버레이 (로드 즉시 켜짐) */
  #ninjaOverlay{
    position:fixed;left:50%;top:50%;
    width:var(--vwpx);height:var(--vhpx);
    transform:translate(-50%,-50%) scale(1);transform-origin:50% 50%;
    border:0;z-index:10;pointer-events:none;opacity:0;
    transition:opacity .35s ease;background:transparent;
    image-rendering:auto;will-change:transform
  }

  /* 프로시니엄 라인 */
  .proscenium{
    position:fixed;
    left:calc(var(--gap) + env(safe-area-inset-left));
    right:calc(var(--gap) + env(safe-area-inset-right));
    top:calc(var(--gap) + env(safe-area-inset-top));
    bottom:calc(var(--gap) + env(safe-area-inset-bottom));
    border:var(--line-w) solid var(--line-color);
    border-radius:var(--line-r);
    box-sizing:border-box;z-index:90;pointer-events:none;transform:translateZ(0)
  }

  /* IN/OUT */
  .controls{
    position:fixed;right:calc(16px + env(safe-area-inset-right));
    bottom:calc(16px + env(safe-area-inset-bottom));
    z-index:100;display:flex;gap:8px
  }
  .uiBtn{ padding:.4em .8em; cursor:pointer; user-select:none; color:#fff; opacity:.9; background:transparent; text-transform:uppercase; letter-spacing:var(--letter-space); }

  /* HTTPS 안내 (필요 시에만) */
  #httpsBlock{
    position:fixed;inset:0;z-index:300;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.88);color:#fff;padding:20px;text-align:center
  }
  #httpsInner{max-width:560px}
  .kbd{display:inline-block;border:1px solid #888;padding:2px 6px;border-radius:4px;background:#111}

  /* 디버그 HUD (3탭 토글) */
  #diag{
    position:fixed;left:8px;bottom:8px;z-index:9999;
    background:rgba(0,0,0,.7);color:#0f0;font:12px/1.4 var(--ff-ui);
    padding:8px;border:1px solid #0f0;border-radius:6px;display:none;white-space:pre
  }

  /* 보이지 않는 ‘첫 제스처’ 캡처 레이어 (텍스트 없이 투명) */
  #activationShim{
    position:fixed;inset:0;z-index:250; /* 카메라 뒤, 오버레이 앞 */
    background:transparent; /* 완전 투명: 화면엔 아무것도 안 보임 */
  }
</style>
</head>
<body>
  <canvas id="view"></canvas>

  <iframe id="ninjaOverlay"
          allow="autoplay; fullscreen; camera; microphone; clipboard-read; clipboard-write"
          allowtransparency="true" style="background:transparent" referrerpolicy="no-referrer"
          src="about:blank"></iframe>

  <div class="proscenium" aria-hidden="true"></div>

  <div class="controls">
    <button class="uiBtn" id="btnIn">IN</button>
    <button class="uiBtn" id="btnOut">OUT</button>
  </div>

  <!-- HTTPS 안내 (필요 시 자동 표시) -->
  <div id="httpsBlock">
    <div id="httpsInner">
      <div style="font-size:18px;margin-bottom:10px"><b>보안 연결(HTTPS) 필요</b></div>
      <div style="opacity:.9">홈 화면 앱에선 HTTP에서 카메라/마이크가 차단돼요.</div>
      <div style="margin:12px 0 8px">아래 주소로 자동 이동하도록 설정하세요:</div>
      <div id="httpsUrlBox" class="kbd" style="user-select:all;display:inline-block;"></div>
      <div style="margin-top:12px">
        <button id="copyHttps" class="uiBtn">주소 복사</button>
        <button id="openHttps" class="uiBtn">열기</button>
      </div>
      <div style="opacity:.7;margin-top:10px;font-size:12px">
        (예: <span class="kbd">cloudflared tunnel --url http://localhost:8001</span> 또는 <span class="kbd">ngrok http 8001</span>)
      </div>
    </div>
  </div>

  <!-- 눈에 보이지 않지만 첫 터치를 잡아 권한 요청 재시도 -->
  <div id="activationShim"></div>

  <div id="diag"></div>

<script>
(()=> {
/* ===== Config ===== */
const CONFIG = { ROOM_ID:"YOURROOMID", HTTPS_ORIGIN:"", BLEND:0.5, REZ_SCALE:0.65 };

/* ===== HTTPS ===== */
const httpsBlock=document.getElementById('httpsBlock');
const httpsBox=document.getElementById('httpsUrlBox');
const btnCopy=document.getElementById('copyHttps');
const btnOpen=document.getElementById('openHttps');
function shouldForceHttps(){ const local=/^(localhost|127\.0\.0\.1)$/i.test(location.hostname); return !window.isSecureContext && !local; }
function tryHttpsRedirect(){
  if(shouldForceHttps()){
    if(CONFIG.HTTPS_ORIGIN){
      const t=new URL(location.href), o=CONFIG.HTTPS_ORIGIN.replace(/\/+$/,'');
      location.replace(o+t.pathname+t.search+t.hash); return true;
    }else{ httpsBox.textContent="(HTTPS 주소 설정: CONFIG.HTTPS_ORIGIN)"; httpsBlock.style.display='flex'; return false; }
  } return false;
}
btnCopy?.addEventListener('click', async ()=>{ if(!CONFIG.HTTPS_ORIGIN) return alert('CONFIG.HTTPS_ORIGIN 비어있음'); try{ await navigator.clipboard.writeText(CONFIG.HTTPS_ORIGIN); alert('복사됨'); }catch{ alert(CONFIG.HTTPS_ORIGIN); } });
btnOpen?.addEventListener('click', ()=>{ if(!CONFIG.HTTPS_ORIGIN) return alert('CONFIG.HTTPS_ORIGIN 비어있음'); location.href=CONFIG.HTTPS_ORIGIN; });
if(!tryHttpsRedirect() && shouldForceHttps()) httpsBlock.style.display='flex';

/* ===== VDO.Ninja (로드 즉시 켜짐) ===== */
const injectedCss=encodeURIComponent(`
  html,body{background:transparent!important;margin:0!important;overflow:hidden!important;}
  #container,.container{background:transparent!important;}
  video,canvas{position:fixed!important; inset:0!important; width:100vw!important; height:100vh!important; object-fit:cover!important; background:transparent!important;}
`);
const ninjaBase=`https://vdo.ninja/?view=${encodeURIComponent(CONFIG.ROOM_ID)}&clean&autostart&noaudio&codec=vp8&solo&transparent=1&css=${injectedCss}`;
const ninjaUrl=()=>`${ninjaBase}&ts=${Date.now()}`;

const view=document.getElementById('view');
const vctx=view.getContext('2d',{alpha:false});
const ninja=document.getElementById('ninjaOverlay');
const btnIn=document.getElementById('btnIn');
const btnOut=document.getElementById('btnOut');
const diag=document.getElementById('diag');
const shim=document.getElementById('activationShim');

/* ===== Viewport fix ===== */
function setViewportVars(){
  const vv=visualViewport, w=Math.round((vv?.width||innerWidth)), h=Math.round((vv?.height||innerHeight));
  document.documentElement.style.setProperty('--vwpx', w+'px');
  document.documentElement.style.setProperty('--vhpx', h+'px');
}
let relayoutTimer=null;
function scheduleLayoutRefresh(d=60){ clearTimeout(relayoutTimer); relayoutTimer=setTimeout(()=>{ setViewportVars(); fitCamera(); applyRezScale(); }, d); }
setViewportVars();
addEventListener('resize', ()=>scheduleLayoutRefresh(80));
addEventListener('orientationchange', ()=>{ scheduleLayoutRefresh(120); scheduleLayoutRefresh(300); });
if(visualViewport){
  visualViewport.addEventListener('resize', ()=>scheduleLayoutRefresh(60));
  visualViewport.addEventListener('scroll', ()=>scheduleLayoutRefresh(60));
}

/* ===== Camera (B/W) ===== */
const cam=document.createElement('video'); cam.autoplay=true; cam.muted=true; cam.playsInline=true;
const proc=document.createElement('canvas'); const pctx=proc.getContext('2d',{willReadFrequently:true});
const PROC_SCALE=0.60;
function fitCamera(){
  const dpr=devicePixelRatio||1;
  const cssW=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vwpx'));
  const cssH=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vhpx'));
  view.width=Math.max(1,Math.round(cssW*dpr)); view.height=Math.max(1,Math.round(cssH*dpr));
  vctx.setTransform(dpr,0,0,dpr,0,0);
  const scale=matchMedia('(orientation:landscape)').matches? PROC_SCALE*0.9 : PROC_SCALE;
  proc.width=Math.max(1,Math.floor(cssW*scale)); proc.height=Math.max(1,Math.floor(cssH*scale));
}
async function startCamera(){
  const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
  cam.srcObject=s; cam.addEventListener('loadedmetadata', ()=>scheduleLayoutRefresh(0), {once:true});
  await cam.play().catch(()=>{});
}
let _loop=false; function ensureLoop(){ if(_loop) return; _loop=true; loop(); }
function loop(){
  requestAnimationFrame(loop);
  const cssW=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vwpx'));
  const cssH=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vhpx'));
  const W=cssW,H=cssH, PW=proc.width, PH=proc.height;
  pctx.clearRect(0,0,PW,PH);
  if (cam.readyState>=2){
    const vw=cam.videoWidth, vh=cam.videoHeight;
    if(vw&&vh){
      const sc=Math.max(PW/vw, PH/vh), dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
      pctx.drawImage(cam,dx,dy,dw,dh);
      const img=pctx.getImageData(0,0,PW,PH), d=img.data;
      for(let i=0;i<d.length;i+=4){ const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g; }
      pctx.putImageData(img,0,0);
    }
  }
  vctx.clearRect(0,0,W,H);
  if(PW>0&&PH>0){
    const sc2=Math.max(W/PW, H/PH), dw2=PW*sc2, dh2=PH*sc2, dx2=(W-dw2)/2, dy2=(H-dh2)/2;
    vctx.drawImage(proc, dx2, dy2, dw2, dh2);
  }
}

/* ===== Audio / Sensors / Mic ===== */
let audioCtx=null, mixBus=null, motionGain=null, masterGain=null, panSetter=null, micStream=null;
const VOL_BASE=0.20,VOL_MAX_ADD=0.55,SMOOTH_TC=0.08,CTRL_SMOOTH_ALPHA=0.12,DEADZONE_VOL_DEG=5,DEADZONE_PAN_DEG=3,VOL_TILT_LIMIT=60,PAN_LIMIT_DEG=45;
function initAudio(){
  if(audioCtx) return;
  audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  mixBus=audioCtx.createGain();
  let panOut=null;
  if(audioCtx.createStereoPanner){
    const sp=audioCtx.createStereoPanner();
    panSetter=v=>{ try{ sp.pan.setTargetAtTime(v,audioCtx.currentTime,0.08);}catch{ sp.pan.value=v; } };
    mixBus.connect(sp); panOut=sp;
  }else{
    const l=audioCtx.createGain(), r=audioCtx.createGain(), m=audioCtx.createChannelMerger(2);
    mixBus.connect(l); mixBus.connect(r); l.connect(m,0,0); r.connect(m,0,1); panOut=m;
    panSetter=p=>{ const x=Math.max(-1,Math.min(1,p||0)), th=(x+1)*0.25*Math.PI; l.gain.value=Math.cos(th); r.gain.value=Math.sin(th); };
  }
  motionGain=audioCtx.createGain(); motionGain.gain.value=VOL_BASE;
  masterGain=audioCtx.createGain(); masterGain.gain.value=1.0;
  panOut.connect(motionGain); motionGain.connect(masterGain); masterGain.connect(audioCtx.destination);
}
async function startMic(){
  const s=await navigator.mediaDevices.getUserMedia({ audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:true}, video:false });
  micStream=s; const src=audioCtx.createMediaStreamSource(s);
  const hpf=audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=120;
  const comp=audioCtx.createDynamicsCompressor(); comp.threshold.value=-40; comp.knee.value=18; comp.ratio.value=2.0; comp.attack.value=0.003; comp.release.value=0.12;
  const wet=audioCtx.createGain(); wet.gain.value=1.0;
  const dry=audioCtx.createGain(); dry.gain.value=0.30;
  const convolver=audioCtx.createConvolver(); convolver.buffer=makeIR(2.4,2.2);
  const micBoost=audioCtx.createGain(); micBoost.gain.value=1.8;
  src.connect(hpf).connect(comp);
  const split=audioCtx.createGain(); comp.connect(split);
  split.connect(dry); split.connect(convolver).connect(wet);
  const bus=audioCtx.createGain(); dry.connect(bus); wet.connect(bus);
  bus.connect(micBoost).connect(mixBus);
}
function makeIR(sec=2.4,decay=2.2){
  const rate=audioCtx.sampleRate,len=Math.floor(rate*sec),ir=audioCtx.createBuffer(2,len,rate);
  for(let c=0;c<2;c++){ const v=ir.getChannelData(c); for(let i=0;i<len;i++){ const t=i/len, env=Math.pow(1-t,decay); v[i]=(Math.random()*2-1)*env*0.55; } }
  return ir;
}
let sensorsReady=false, latestOri={beta:0,gamma:0}, smVol=VOL_BASE, smPan=0;
async function sensorPerm(){
  try{
    if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
      const r=await DeviceOrientationEvent.requestPermission(); if(r==='granted') sensorsReady=true;
    } else { sensorsReady=true; }
  }catch{}
  try{
    if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      const r=await DeviceMotionEvent.requestPermission(); if(r==='granted') sensorsReady=true;
    }
  }catch{}
}
function initOrientation(){ addEventListener('deviceorientation',e=>{ latestOri.beta=e.beta??0; latestOri.gamma=e.gamma??0; },{passive:true}); }
function smooth(t,c,a=CTRL_SMOOTH_ALPHA){ return c+(t-c)*a; }
function ctlLoop(){
  requestAnimationFrame(ctlLoop);
  let pan=0, vol=VOL_BASE;
  if(sensorsReady){
    const ang=(screen.orientation?.angle)||0, beta=latestOri.beta||0, gamma=latestOri.gamma||0;
    const panTilt=(ang%180===0)? gamma : beta;
    const volTilt=(ang%180===0)? beta  : -gamma;
    pan = Math.max(-1,Math.min(1,(Math.abs(panTilt)<DEADZONE_PAN_DEG?0:panTilt/PAN_LIMIT_DEG)));
    const a = Math.max(0,(Math.abs(volTilt)-DEADZONE_VOL_DEG)/(VOL_TILT_LIMIT-DEADZONE_VOL_DEG));
    vol = VOL_BASE + VOL_MAX_ADD*a;
  }
  smPan=smooth(pan,smPan); smVol=smooth(vol,smVol);
  if(panSetter) panSetter(smPan);
  if(motionGain){ const now=audioCtx.currentTime; try{ motionGain.gain.setTargetAtTime(smVol,now,SMOOTH_TC);}catch{ motionGain.gain.value=smVol; } }
}

/* ===== Geolocation (가능하면 즉시 요청) ===== */
async function requestGeo(){
  if(!("geolocation" in navigator)) return;
  try{
    await new Promise((res,rej)=>{
      navigator.geolocation.getCurrentPosition(()=>res(),()=>rej(),{enableHighAccuracy:true,timeout:4000,maximumAge:0});
    });
  }catch{}
}

/* ===== Rez Scale ===== */
function applyRezScale(){
  const s=Math.max(0.2, Math.min(1, Number(CONFIG.REZ_SCALE)||1));
  ninja.style.width=`calc(var(--vwpx) * ${s})`;
  ninja.style.height=`calc(var(--vhpx) * ${s})`;
  ninja.style.left='50%'; ninja.style.top='50%';
  ninja.style.transform=`translate(-50%,-50%) scale(${1/s})`;
}

/* ===== Ninja overlay: 로드 즉시 표시 ===== */
(function preloadOverlay(){ ninja.src=ninjaUrl(); })();
function setOverlay(on){ ninja.style.opacity = on ? String(CONFIG.BLEND) : '0'; if (on && !ninja.contentWindow) ninja.src=ninjaUrl(); }
setInterval(()=>{ if(ninja.style.opacity!=='0'){ ninja.src=ninjaUrl(); } }, 60000);

/* ===== 권한/초기화 시퀀스 ===== */
let bootTried=false;
async function bootSequence(){
  if(bootTried) return; bootTried=true;

  // 1) Ninja 즉시 표시
  applyRezScale(); setOverlay(true);

  // 2) 오디오/센서 초기화
  initAudio();
  // 일부 브라우저는 resume에 제스처 필요 → 실패해도 무시
  try{ await audioCtx.resume(); }catch{}

  // 3) 위치, 센서 권한 시도 (센서는 iOS에선 제스처 필요할 수 있음)
  requestGeo().catch(()=>{});
  initOrientation();

  // 4) 카메라/마이크: 제스처 필요 없는 환경은 즉시 허용창 뜸.
  try{
    await startCamera();
  }catch(e){
    // 제스처 필요 시 재시도는 아래 activationShim에서 처리
  }
  ensureLoop();

  try{
    await startMic();
  }catch(e){
    // 제스처 필요 시 재시도는 아래 activationShim에서 처리
  }

  // 5) 센서 권한 요청 (iOS는 반드시 제스처 필요)
  try{ await sensorPerm(); }catch{}
}

/* 첫 로드에서 한 번 시도 */
document.addEventListener('DOMContentLoaded', bootSequence);

/* 제스처 필요 환경 대응: 화면 어디든 첫 터치/클릭에서 재시도 */
async function activateOnce(){
  // iOS 권한 재요청
  try{ await audioCtx?.resume(); }catch{}
  try{ await sensorPerm(); }catch{}
  // 카메라/마이크 재시도
  try{ await startCamera(); }catch{}
  try{ await startMic(); }catch{}
  // 완료 후 보이지 않는 캡처 레이어 제거
  shim.removeEventListener('pointerdown', activateOnce);
  shim.removeEventListener('click', activateOnce);
  shim.style.display='none';
}
shim.addEventListener('pointerdown', activateOnce, {once:true, passive:true});
shim.addEventListener('click', activateOnce, {once:true});

/* IN/OUT 오버레이 토글 */
btnIn.addEventListener('click', ()=> setOverlay(true));
btnOut.addEventListener('click',()=> setOverlay(false));

/* HUD (3탭) */
(function(){
  let show=false,taps=0,last=0;
  addEventListener('touchend', ()=>{
    const now=Date.now(); taps = (now-last<400)? (taps+1):1; last=now;
    if(taps>=3){ show=!show; diag.style.display=show?'block':'none'; if(show) probe(); }
  });
  async function probe(){
    const secure=window.isSecureContext, a2hs=matchMedia('(display-mode: standalone)').matches;
    let camP='unknown', micP='unknown', geo='unknown';
    try{ const ps=await navigator.permissions.query({name:'camera'}).catch(()=>null); camP=ps?ps.state:'n/a'; }catch{}
    try{ const ps=await navigator.permissions.query({name:'microphone'}).catch(()=>null); micP=ps?ps.state:'n/a'; }catch{}
    try{ const ps=await navigator.permissions.query({name:'geolocation'}).catch(()=>null); geo=ps?ps.state:'n/a'; }catch{}
    diag.textContent =
`secureContext: ${secure}
display-mode: ${a2hs?'standalone':'browser'}
viewport: ${innerWidth}x${innerHeight}
rez-scale: ${CONFIG.REZ_SCALE}
camera perm: ${camP}
microphone perm: ${micP}
geolocation perm: ${geo}
time: ${new Date().toLocaleTimeString()}`;
    if(diag.style.display==='block') setTimeout(probe, 800);
  }
})();

/* 가시성 복귀 시 재개/리레이아웃 */
document.addEventListener('visibilitychange', ()=>{
  if(document.visibilityState==='visible'){
    if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
    scheduleLayoutRefresh(0);
  }
});

fitCamera(); applyRezScale();

})();
</script>
</body>
</html>
